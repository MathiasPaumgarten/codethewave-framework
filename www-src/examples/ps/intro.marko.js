function create(__helpers) {
  var str = __helpers.s,
      empty = __helpers.e,
      notEmpty = __helpers.ne;

  return function render(data, out) {
    out.w('<!doctype html> <html class="no-js" lang><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><title>Hue</title><meta name="description" content><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><link rel="apple-touch-icon" href="apple-touch-icon.png"><link rel="stylesheet" href="../../main.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/detectizr/2.2.0/detectizr.min.js"></script><script src="../../js/pixi.min.js"></script><script src="../../js/TweenMax.min.js"></script></head><body><!--[if lt IE 8]>\n\n        <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>\n\n    <![endif]--><script src="../../sp-framework.js"></script><script>\n\n        var DEG2RAD = Math.PI / 180.0;\n\n        var backgroundContainer;\n        var leafTexture;\n        var hueFilter;\n\n        var leafs = [];\n        \n        var leafSize = 250;\n        var leafDiagonalSize = leafSize * Math.sqrt(2) * 0.5;\n        var leafAspect = 1;\n        var leafMaximumSpeed = 5;\n        var leafAcceleration= 0.025;\n        var leafMaximumRotationSpeed = 2 * DEG2RAD;\n\n        var maximumLeafCount = 50;\n        var lastSpawnPosition = new Vector2(-1000, -1000);\n        var lastMousePosition = new Vector2(-1000, -1000);\n        var currentMousePosition = new Vector2(0,0);\n        var minimumSpawnDistance = 50;\n\n\n        var lastSpawnTime;\n        var spawnIntervalMillisStart = 1500;\n        var spawnIntervalMillisEnd = 250;\n        var spawnIntervalDecrease = 50; \n        var spawnIntervalMillis = spawnIntervalMillisStart;\n\n        var leafHueFilter;\n\n        print = console.log;//TEMP\n\n        function spawnLeaf(PIXI, input)\n        {\n            lastSpawnTime = new Date().getTime();\n            if(spawnIntervalMillis > spawnIntervalMillisEnd)\n            {\n                spawnIntervalMillis -= spawnIntervalDecrease;\n            }\n            \n            //Spawn\n            var params = {\n                size: leafSize, \n                container: backgroundContainer, \n                animate: true, \n                duration: -1,  \n                inDuration: 0.5, \n                //outDuration: 0.25, \n                startScale: 0.5,\n                easeIn: Back.easeOut.config(1.7)\n            };\n\n            if( input.mouseTouchPosition.x != 0 &&  input.mouseTouchPosition.y != 0)\n            {  \n                var mousePosition = new Vector2(input.mouseTouchPosition.x, input.mouseTouchPosition.y); \n                if(lastSpawnPosition.distance(mousePosition) > minimumSpawnDistance && lastMousePosition.distance(mousePosition) > minimumSpawnDistance)\n                {\n                    params.x = input.mouseTouchPosition.x;\n                    params.y = input.mouseTouchPosition.y;\n                }\n            }\n\n            var leaf = spawn(PIXI, input, leafTexture, params);\n            \n            lastSpawnPosition = new Vector2(leaf.x, leaf.y);\n            lastMousePosition = new Vector2(input.mouseTouchPosition.x, input.mouseTouchPosition.y);\n\n            //Animation\n            var leafAnimator = new SpriteAnimator(leaf);\n            leafAnimator.speed = 0.0;\n            leafAnimator.maxSpeed = leafMaximumSpeed;\n            leafAnimator.acceleration = leafAcceleration;\n            leafAnimator.rotationSpeed = (Math.random() * 2.0 - 1.0) * leafMaximumRotationSpeed;\n            var center = new Vector2(input.width / 2, input.height / 2);\n            var direction = lastSpawnPosition.subtract(center);\n            direction.normalize();\n            leafAnimator.direction = direction;\n            leafs.push(leafAnimator);\n\n            while (backgroundContainer.children.length >= maximumLeafCount)\n            {\n                removeLeaf(0);\n            }\n        }\n\n        function removeLeaf(i)\n        {\n            if (i < 0)\n            {\n                return;\n            }\n\n            backgroundContainer.removeChildAt(i);\n            leafs.splice(i, 1);\n        }\n\n        SPF.set({\n\n            at:"back",\n            load: function(PIXI, input) \n            {\n                //TODO: Preload textures. First move them into framework\n                return [];\n                //return [input.patterns.animaltech];\n            },\n\n            init: function(PIXI, input) \n            {\n                //TODO: Move textures into framework\n                leafTexture = PIXI.Texture.fromImage(\'../../assets/ps_temp/SP_element_leaf_001.png\'); //TODO: Load from framework\n                leafTexture.baseTexture.wrapMode = PIXI.WRAP_MODES.CLAMP\n\n                backgroundContainer = new PIXI.Container();\n                input.container.addChild(backgroundContainer);\n\n\t            leafHueFilter = new PIXI.filters.ColorMatrixFilter();\n                backgroundContainer.filters = [leafHueFilter];\n                \n                leafHueFilter.hue(30);\n                leafHueFilter.brightness(0.5, true);\n                leafHueFilter.saturate(2, true);\n\n                lastSpawnTime = new Date().getTime();\n            },\n\n            //TODO: Animate framerate independent using delta time\n            render:function(PIXI, input)\n            {\n                //Auto spawn leafs (TODO: Use beat to spawn, for now timed)\n                var timeSinceSpawn = new Date().getTime() - lastSpawnTime;\n                if (timeSinceSpawn > spawnIntervalMillis)\n                {\n                    spawnLeaf(PIXI, input);\n                }\n                //Animate leafs\n                var removeIndices = [];\n                for (var i = 0;i < leafs.length; i++)\n                {\n                    leafs[i].update(0);\n                    \n                    //remove when outside view\n                    if(leafs[i].sprite.x < -leafDiagonalSize || leafs[i].sprite.x > leafDiagonalSize + input.width || leafs[i].sprite.y < -leafDiagonalSize || leafs[i].sprite.y > leafDiagonalSize + input.height)\n                    {   \n                        removeIndices.push(i);\n                    }\n                }\n                \n                while(removeIndices.length > 0)\n                {\n                    removeLeaf(removeIndices[0]);\n                    removeIndices.shift();\n                }\n                \n            },\n\n            mouseDownTouchStart: function(PIXI, input)\n            {\n                spawnLeaf(PIXI, input);\n            }\n        });\n\n        var leftFrontLeaf, rightFrontLeaf;\n        var leafEdgeInset = 250;\n\n        var beatInterval = 1000;//millis\n        var lastBeatTime;\n        var edgeLeafRotationSpeed = 0;\n\n        SPF.set({\n\n            at:"fore",\n            load: function(PIXI, input) \n            {\n                //return [input.patterns.animaltech];\n                return [];\n            },\n\n            init: function(PIXI, input) \n            {\n                frontLeafTexture = PIXI.Texture.fromImage(\'../../assets/ps_temp/SP_element_leaf_palm_001.png\'); //TODO: Load from framework\n                frontLeafTexture.baseTexture.wrapMode = PIXI.WRAP_MODES.CLAMP\n\n                leftFrontLeaf = new PIXI.Sprite(frontLeafTexture);\n                leftFrontLeaf.anchor.set(0.5);\n                rightFrontLeaf = new PIXI.Sprite(frontLeafTexture);\n                rightFrontLeaf.anchor.set(0.5);\n                \n                input.container.addChild(leftFrontLeaf);\n                input.container.addChild(rightFrontLeaf);\n\n                leftFrontLeaf.tint = 0x000000;\n                rightFrontLeaf.tint = 0x000000;\n\n                leftFrontLeaf.alpha = 0;\n                rightFrontLeaf.alpha = 0;\n\n                var delay = 4.0;\n                TweenMax.to(leftFrontLeaf, 0.5, {alpha:1,delay: delay});\n                TweenMax.to(rightFrontLeaf, 0.5, {alpha:1,delay: delay});\n\n                lastBeatTime = new Date().getTime();\n            },\n\n            render:function(PIXI, input)\n            {\n                //TODO: Replace by beat detection\n                var timeSinceBeat = new Date().getTime() - lastBeatTime;\n                if (timeSinceBeat > beatInterval)\n                {\n                    lastBeatTime = new Date().getTime();\n                    edgeLeafRotationSpeed = 15 * DEG2RAD;\n                }\n\n                edgeLeafRotationSpeed *= 0.75;\n                leftFrontLeaf.rotation += edgeLeafRotationSpeed;\n                rightFrontLeaf.rotation -= edgeLeafRotationSpeed;\n            },\n\n            resize: function(PIXI, input) \n            {\n                leftFrontLeaf.scale.x = leftFrontLeaf.scale.y = rightFrontLeaf.scale.x = rightFrontLeaf.scale.y = input.height / 700;\n                leftFrontLeaf.x = -leafEdgeInset;\n                leftFrontLeaf.y = input.height / 1.75;\n                rightFrontLeaf.x = input.width + leafEdgeInset;\n                rightFrontLeaf.y = input.height / 1.75;\n            }\n        });\n\n        SPF.info({\n            debug: false,\n            title: "Intro",\n            tip: "Click to add leafs",\n            firstName: "Patrik",\n            lastName: "Svensson",\n            email: "ps@molamil.com"\n        });\n\n        SPF.start();\n\n\n        //HELPERS\n        spawn = function(PIXI, input, texture, params)\n        {\n            var spawnee = new PIXI.Sprite(texture);\n            spawnee.anchor.set(0.5);\n            spawnee.rotation = Math.random() * 2 * Math.PI;\n            spawnee.x = ("x" in params) ? params.x : Math.random() * input.width;\n            spawnee.y = ("y" in params) ? params.y : Math.random() * input.height;\n\n            var spawneeMirrored = null;\n            if(("mirrored" in params))\n            {\n                if(params.mirrored == true)\n                {\n                    console.log("mirrored spawn")\n                }\n            }\n\n            if(("size" in params))\n            {\n                var aspect = texture.width / texture.height;\n                if (aspect > 1)\n                {\n                    spawnee.width = params.size;\n                    spawnee.height = params.size / aspect;\n                }\n                else\n                {\n                    spawnee.height = params.size;\n                    spawnee.width = params.size * aspect;\n                }\n            }\n\n            if(("container" in params))\n            {\n                params.container.addChild(spawnee);\n            }\n            else\n            {\n                input.container.addChild(spawnee);\n            }\n\n            if(("animate" in params))\n            {\n                if(params.animate == true)\n                {\n                    spawnee.alpha = 0;\n                    var duration = ("duration" in params) ? params.duration : -1.0;\n                    var inDuration = ("inDuration" in params) ? params.inDuration : 0.25; //0-1\n                    var outDuration = ("outDuration" in params) ? params.outDuration : 0.25;//0-1\n\n                    //TweenMax.to(spawnee, 0.5, {alpha:1});\n                    animationParams = duration > 0 ? {onComplete:destroySpawnee, onCompleteParams:[spawnee]} : {}\n                    var alphaTimeline = new TimelineMax(animationParams);\n                    alphaTimeline.to(spawnee, inDuration,{alpha:1})\n                    if (duration > 0)\n                    {\n                        alphaTimeline.to(spawnee, outDuration, {delay:1 - outDuration, alpha:0})\n                        alphaTimeline.duration(duration);\n                    }\n\n                    if(("startScale" in params))\n                    {\n                        var startScale = params.startScale;\n                        var targetScale = spawnee.scale.x;\n                        var easeIn = ("easeIn" in params) ? params.easeIn : Power2.easeOut;\n                        var easeOut = ("easeOut" in params) ? params.easeOut : Power2.easeIn;\n                        \n                        spawnee.scale.x = spawnee.scale.y = targetScale * startScale;\n\n                        var scaleTimeline = new TimelineMax(animationParams);\n                        scaleTimeline.to(spawnee.scale, inDuration,{x:targetScale, y:targetScale, ease: easeIn})\n                        if (duration > 0)\n                        {\n                            scaleTimeline.to(spawnee.scale, outDuration, {delay:1 - outDuration, x:targetScale * startScale, y:targetScale * startScale, ease: easeOut})\n                            scaleTimeline.duration(duration);\n                        }\n                    }\n                }\n            }\n\n            return spawnee;\n        }\n\n        destroySpawnee = function(spawnee)\n        {\n            if (!spawnee.parent)\n            {\n                return;\n            }\n            spawnee.parent.removeChild(spawnee);\n        }\n\n        //Vector2 \n        function Vector2(x, y)\n        {\n            this.x = x || 0;\n            this.y = y || 0;\n        };\n\n        Vector2.prototype.x = null;\n        Vector2.prototype.y = null;\n        Vector2.prototype.add = function (v) {\n            return new Vector2(this.x + v.x, this.y + v.y);\n        };\n        Vector2.prototype.clone = function () {\n            return new Vector2(this.x, this.y);\n        };\n        Vector2.prototype.distance = function (v) {\n            var x = this.x - v.x;\n            var y = this.y - v.y;\n            return Math.sqrt(x * x + y * y);\n        };\n        Vector2.prototype.equals = function (toCompare) {\n            return this.x == toCompare.x && this.y == toCompare.y;\n        };\n        Vector2.prototype.interpolate = function (v, f) {\n            return new Vector2((this.x + v.x) * f, (this.y + v.y) * f);\n        };\n        Vector2.prototype.length = function () {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        };\n        Vector2.prototype.sqrLength = function () {\n            return this.x * this.x + this.y * this.y;\n        };\n        Vector2.prototype.normalize = function (thickness = 1) {\n            var l = this.length();\n            this.x = this.x / l * thickness;\n            this.y = this.y / l * thickness;\n        };\n        Vector2.prototype.offset = function (dx, dy) {\n            this.x += dx;\n            this.y += dy;\n        };\n        Vector2.prototype.subtract = function (v) {\n            return new Vector2(this.x - v.x, this.y - v.y);\n        };\n        Vector2.prototype.toString = function () {\n            return "(x=" + this.x + ", y=" + this.y + ")";\n        };\n\n        Vector2.interpolate = function (pt1, pt2, f) {\n            return new Vector2((pt1.x + pt2.x) * f, (pt1.y + pt2.y) * f);\n        };\n        Vector2.distance = function (pt1, pt2) {\n            var x = pt1.x - pt2.x;\n            var y = pt1.y - pt2.y;\n            return Math.sqrt(x * x + y * y);\n        };\n\n        SpriteAnimator = function(sprite)\n        {\n            this.sprite = sprite || null;\n        };\n\n        SpriteAnimator.prototype.sprite = null;\n        SpriteAnimator.prototype.speed = 0;\n        SpriteAnimator.prototype.maxSpeed = 0;\n        SpriteAnimator.prototype.acceleration = 0;\n        SpriteAnimator.prototype.rotationSpeed = 0;\n        SpriteAnimator.prototype.direction = new Vector2(0,0);\n        SpriteAnimator.prototype.update = function(deltaTime)\n        {\n            this.speed = Math.min(this.speed + this.acceleration, this.maxSpeed);\n            this.sprite.x += this.direction.x * this.speed;\n            this.sprite.y += this.direction.y * this.speed;\n            this.sprite.rotation += this.rotationSpeed;\n        };\n    </script></body></html>');
  };
}
(module.exports = require("marko").c(__filename)).c(create);