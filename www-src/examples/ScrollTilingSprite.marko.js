function create(__helpers) {
  var str = __helpers.s,
      empty = __helpers.e,
      notEmpty = __helpers.ne;

  return function render(data, out) {
    out.w('<!doctype html> <html class="no-js" lang><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><title>Scroll Tiling Sprite</title><meta name="description" content><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><link rel="apple-touch-icon" href="apple-touch-icon.png"><link rel="stylesheet" href="../main.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/detectizr/2.2.0/detectizr.min.js"></script><script src="../js/pixi.min.js"></script><script src="../js/TweenMax.min.js"></script></head><body><!--[if lt IE 8]>\n\n        <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>\n\n    <![endif]--><script src="../sp-framework.js"></script><script>\n\n\n        function Point(x, y){\n            this.x = x || 0;\n            this.y = y || 0;\n        };\n\n        Point.prototype.x = null;\n        Point.prototype.y = null;\n        Point.prototype.add = function(v){\n            return new Point(this.x + v.x, this.y + v.y);\n        };\n        Point.prototype.clone = function(){\n            return new Point(this.x, this.y);\n        };\n        Point.prototype.degreesTo = function(v){\n            var dx = this.x - v.x;\n            var dy = this.y - v.y;\n            var angle = Math.atan2(dy, dx); // radians\n            return angle * (180 / Math.PI); // degrees\n        };\n        Point.prototype.distance = function(v){\n            var x = this.x - v.x;\n            var y = this.y - v.y;\n            return Math.sqrt(x * x + y * y);\n        };\n        Point.prototype.equals = function(toCompare){\n            return this.x == toCompare.x && this.y == toCompare.y;\n        };\n        Point.prototype.interpolate = function(v, f){\n            return new Point((this.x + v.x) * f, (this.y + v.y) * f);\n        };\n        Point.prototype.length = function(){\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        };\n        Point.prototype.normalize = function(thickness){\n            var l = this.length();\n            this.x = this.x / l * thickness;\n            this.y = this.y / l * thickness;\n        };\n        Point.prototype.orbit = function(origin, arcWidth, arcHeight, degrees){\n            var radians = degrees * (Math.PI / 180);\n            this.x = origin.x + arcWidth * Math.cos(radians);\n            this.y = origin.y + arcHeight * Math.sin(radians);\n        };\n        Point.prototype.offset = function(dx, dy){\n            this.x += dx;\n            this.y += dy;\n        };\n        Point.prototype.subtract = function(v){\n            return new Point(this.x - v.x, this.y - v.y);\n        };\n        Point.prototype.toString = function(){\n            return "(x=" + this.x + ", y=" + this.y + ")";\n        };\n\n        Point.interpolate = function(pt1, pt2, f){\n            return new Point((pt1.x + pt2.x) * f, (pt1.y + pt2.y) * f);\n        };\n        Point.polar = function(len, angle){\n            return new Point(len * Math.sin(angle), len * Math.cos(angle));\n        };\n        Point.distance = function(pt1, pt2){\n            var x = pt1.x - pt2.x;\n            var y = pt1.y - pt2.y;\n            return Math.sqrt(x * x + y * y);\n        };\n\n        var mousePoint, screenCenterPoint;\n\n        var sprite;\n\n        SPF.set({\n\n            at:"back",\n\n            load: function(PIXI, input) {\n                return [input.patterns.botanicorganic1];\n            },\n\n            init: function(PIXI, input) {\n\n                sprite = new PIXI.extras.TilingSprite(input.patterns.botanicorganic1, 1, 1);\n                sprite.anchor.set(0);\n                input.container.addChild(sprite);\n\n                screenCenterPoint = new Point(input.width/2, input.height/2);\n            },\n\n            render:function(PIXI, input){\n\n                mousePoint = new Point(input.mouseTouchPosition.x, input.mouseTouchPosition.y);\n\n                var speed = (1/100)*Point.distance(mousePoint, screenCenterPoint);\n\n                if(input.mouseTouchPosition.y > input.height/2){\n                    sprite.tilePosition.y -= speed;\n                } else {\n                    sprite.tilePosition.y += speed;\n                }\n\n                if(input.mouseTouchPosition.x > input.width/2){\n                    sprite.tilePosition.x -= speed;\n                } else {\n                    sprite.tilePosition.x += speed;\n                }\n\n\n            },\n\n            resize: function(PIXI, input) {\n\n                var w =  input.width;\n                var h =  input.height;\n\n                screenCenterPoint = new Point(w/2, h/2);\n\n                sprite.width = w;\n                sprite.height = h;\n\n\n            }\n\n        });\n\n\n\n        SPF.info({\n            debug: false,\n            title: "Scroll Tiling Sprite",\n            tip: "Move the cursor around or tap and drag to change the directions of the scrolling.",\n            firstName: "Ramiro",\n            lastName: "Espada",\n            email: "re@ramiroespada.com"\n        });\n\n        SPF.start();\n\n    </script></body></html>');
  };
}
(module.exports = require("marko").c(__filename)).c(create);