function create(__helpers) {
  var str = __helpers.s,
      empty = __helpers.e,
      notEmpty = __helpers.ne;

  return function render(data, out) {
    out.w('<!doctype html> <html class="no-js" lang><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><title>RE3</title><meta name="description" content><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><link rel="apple-touch-icon" href="apple-touch-icon.png"><link rel="stylesheet" href="main.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/detectizr/2.2.0/detectizr.min.js"></script><script src="./js/pixi.min.js"></script></head><body><!--[if lt IE 8]>\n\n        <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>\n\n    <![endif]--><script src="sp-framework.js"></script><script>\n\n\n        function Point(x, y){\n            this.x = x || 0;\n            this.y = y || 0;\n        };\n\n        Point.prototype.x = null;\n        Point.prototype.y = null;\n        Point.prototype.add = function(v){\n            return new Point(this.x + v.x, this.y + v.y);\n        };\n        Point.prototype.clone = function(){\n            return new Point(this.x, this.y);\n        };\n        Point.prototype.degreesTo = function(v){\n            var dx = this.x - v.x;\n            var dy = this.y - v.y;\n            var angle = Math.atan2(dy, dx); // radians\n            return angle * (180 / Math.PI); // degrees\n        };\n        Point.prototype.distance = function(v){\n            var x = this.x - v.x;\n            var y = this.y - v.y;\n            return Math.sqrt(x * x + y * y);\n        };\n        Point.prototype.equals = function(toCompare){\n            return this.x == toCompare.x && this.y == toCompare.y;\n        };\n        Point.prototype.interpolate = function(v, f){\n            return new Point((this.x + v.x) * f, (this.y + v.y) * f);\n        };\n        Point.prototype.length = function(){\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        };\n        Point.prototype.normalize = function(thickness){\n            var l = this.length();\n            this.x = this.x / l * thickness;\n            this.y = this.y / l * thickness;\n        };\n        Point.prototype.orbit = function(origin, arcWidth, arcHeight, degrees){\n            var radians = degrees * (Math.PI / 180);\n            this.x = origin.x + arcWidth * Math.cos(radians);\n            this.y = origin.y + arcHeight * Math.sin(radians);\n        };\n        Point.prototype.offset = function(dx, dy){\n            this.x += dx;\n            this.y += dy;\n        };\n        Point.prototype.subtract = function(v){\n            return new Point(this.x - v.x, this.y - v.y);\n        };\n        Point.prototype.toString = function(){\n            return "(x=" + this.x + ", y=" + this.y + ")";\n        };\n\n        Point.interpolate = function(pt1, pt2, f){\n            return new Point((pt1.x + pt2.x) * f, (pt1.y + pt2.y) * f);\n        };\n        Point.polar = function(len, angle){\n            return new Point(len * Math.sin(angle), len * Math.cos(angle));\n        };\n        Point.distance = function(pt1, pt2){\n            var x = pt1.x - pt2.x;\n            var y = pt1.y - pt2.y;\n            return Math.sqrt(x * x + y * y);\n        };\n\n        var background;\n\n        SPF.set({\n\n            at:"back",\n\n\n            load: function(PIXI, input) {\n                return [input.patterns.animaltech];\n            },\n\n            init: function(PIXI, input) {\n\n                background = new PIXI.extras.TilingSprite(input.patterns.animaltech, 1, 1);\n                background.anchor.set(0);\n                input.container.addChild(background);\n\n            },\n\n            resize :function(PIXI, input) {\n                var w =  input.width;\n                var h =  input.height;\n\n                background.width = w*2;\n                background.height = h*2;\n            }\n\n        });\n\n\n        var points;\n        var ropeLength;\n        var wave;\n        var count;\n        var screenCenterPoint;\n        var mousePoint;\n        var maxDistance;\n        var centerScreenDistance;\n\n        function createWave(PIXI, input){\n\n            var w =  input.width;\n            var h =  input.height;\n\n            screenCenterPoint = new Point(w/2, h/2);\n\n            maxDistance = Point.distance(new Point(0,0), screenCenterPoint);\n\n            var totalPoints = 20;\n            ropeLength = (w+1200) / totalPoints;\n\n            count = 0;\n\n            // Remove existing graphics to create them again on resize!\n\n            if(wave != null){\n                input.container.removeChild(wave);\n            }\n\n            points = [];\n            for (var i = 0; i < totalPoints; i++){\n                points.push(new PIXI.Point(i * ropeLength, 0));\n            }\n\n            wave = new PIXI.mesh.Rope(input.patterns.animaltech, points);\n\n            wave.height = h*2.5;\n            wave.position.x = -600;\n            wave.position.y = h/2;\n\n            input.container.addChild(wave);\n\n        };\n\n\n        SPF.set({\n\n            at:"mid",\n\n            load: function(PIXI, input) {\n                return [input.patterns.animaltech];\n            },\n            init: function(PIXI, input) {\n\n                createWave(PIXI, input);\n                wave.alpha = 0;\n\n\n            },\n\n            render:function(PIXI, input){\n\n                if(wave == null)\n                    return;\n\n                var fs = input.audio.frequencies();\n\n                var f = 0;\n                var fAvailable = 0;\n\n                if(fs) {\n\n                    for(var i=0;i<fs.length; i++){\n                        if(fs[i] > 0){\n                            f += fs[i];\n                            fAvailable++;\n                        }\n                    }\n\n                    f = 10 + (f/(255*fAvailable))*50;\n\n                };\n\n\n                wave.position.y = input.mouseTouchPosition.y;\n\n                mousePoint = new Point(input.mouseTouchPosition.x, input.mouseTouchPosition.y);\n\n                centerScreenDistance = (1/maxDistance)*Point.distance(mousePoint, screenCenterPoint);\n\n                count += 0.1;\n\n                for (var i = 0; i < points.length; i++) {\n\n                    points[i].y = Math.sin((i * 0.5) + count) * (70 -(50*centerScreenDistance));\n\n                    points[i].x = i * ropeLength + Math.cos((i * 0.3) + count) * (200-(200*centerScreenDistance));\n\n                }\n\n\n            },\n\n            resize :function(PIXI, input) {\n                if(wave){\n                    input.container.removeChild(wave);\n                    wave = null;\n                    createWave(PIXI, input);\n                    wave.alpha = 1;\n                }\n\n            }\n\n        });\n\n        SPF.info({debug:false, title:"RE WAVES", tip:"Mouve your cursor or finger around to change the size and position of the wave.", firstName:"Ramiro", lastName:"Espada", email:"re@ramiroespada.com"});\n\n        SPF.start("intro");\n\n\n\n    </script></body></html>');
  };
}
(module.exports = require("marko").c(__filename)).c(create);