<!doctype html>

<html class="no-js" lang="">

    <head>

        <meta charset="utf-8">

        <meta http-equiv="x-ua-compatible" content="ie=edge">

        <title>sp-framework</title>

        <meta name="description" content="">

        <meta name = "viewport" content = "user-scalable=no, width=device-width">

        <link rel="apple-touch-icon" href="apple-touch-icon.png">

        <link rel="stylesheet" href="main.css"/>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/detectizr/2.2.0/detectizr.min.js"></script>

        <script src="http://work.molamil.com/trouble/spxboplay/sp-framework/js/pixi.js"></script>

        <script src="./js/popcorn.js"></script>

    </head>

    <body>

    <!--[if lt IE 8]>

        <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>

    <![endif]-->

    <script src="sp-framework.js"></script>
    <script id="fragShader" type="shader-code">
    precision mediump float;
    uniform vec2      resolution;
    uniform float     globalTime;
    
    
    
    vec3 firePalette(float i){

        float T = 1400. + 1300.*i; // Temperature range (in Kelvin).
        vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).
        L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);
        return 1.0-exp(-5e8/L); // Exposure level. Set to "50." For "70," change the "5" to a "7," etc.
    }
    // Hash function. This particular one probably doesn't disperse things quite as nicely as some 
    // of the others around, but it's compact, and seems to work.
    //
    vec3 hash33(vec3 p){ 
        
        float n = sin(dot(p, vec3(7, 157, 113)));    
        return fract(vec3(2097152, 262144, 32768)*n); 
    }
    // 3D Voronoi: Obviously, this is just a rehash of IQ's original.
    //
    float voronoi(vec3 p){

        vec3 b, r, g = floor(p);
        p = fract(p); // "p -= g;" works on some GPUs, but not all, for some annoying reason.
        
        // Maximum value: I think outliers could get as high as "3," the squared diagonal length 
        // of the unit cube, with the mid point being "0.75." Is that right? Either way, for this 
        // example, the maximum is set to one, which would cover a good part of the range, whilst 
        // dispensing with the need to clamp the final result.
        float d = 1.; 
         
        
        for(int j = -1; j <= 1; j++) {
            for(int i = -1; i <= 1; i++) {
                
                b = vec3(i, j, -1);
                r = b - p + hash33(g+b);
                d = min(d, dot(r,r));
                
                b.z = 0.0;
                r = b - p + hash33(g+b);
                d = min(d, dot(r,r));
                
                b.z = 1.;
                r = b - p + hash33(g+b);
                d = min(d, dot(r,r));
                    
            }
        }
        
        return d; // Range: [0, 1]
    }
    // Standard fBm function with some time dialation to give a parallax 
    // kind of effect. In other words, the position and time frequencies 
    // are changed at different rates from layer to layer.
    //
    float noiseLayers(vec3 p) {

        // Normally, you'd just add a time vector to "p," and be done with 
        // it. However, in this instance, time is added seperately so that 
        // its frequency can be changed at a different rate. "p.z" is thrown 
        // in there just to distort things a little more.
        vec3 t = vec3(0., 0., p.z+globalTime*1.5);

        const int iter = 5; // Just five layers is enough.
        float tot = 0., sum = 0., amp = 1.; // Total, sum, amplitude.

        for (int i = 0; i < iter; i++) {
            tot += voronoi(p + t) * amp; // Add the layer to the total.
            p *= 2.0; // Position multiplied by two.
            t *= 1.5; // Time multiplied by less than two.
            sum += amp; // Sum of amplitudes.
            amp *= 0.5; // Decrease successive layer amplitude, as normal.
        }
        
        return tot/sum; // Range: [0, 1].
    }
    void main(){
        
        // Screen coordinates.
        vec2 uv = (gl_FragCoord.xy - resolution.xy*0.5) / resolution.y;
        
        // Shifting the central position around, just a little, to simulate a 
        // moving camera, albeit a pretty lame one.
        uv += vec2(sin(globalTime*0.5)*0.25, cos(globalTime*0.5)*0.125);
        
        // Constructing the unit ray. 
        vec3 rd = normalize(vec3(uv.x, uv.y, 3.1415926535898/8.));

        // Rotating the ray about the XY plane, to simulate a rolling camera.
        float cs = cos(globalTime*0.25), si = sin(globalTime*0.25);
        // Apparently "r *= rM" can break in some older browsers.
        rd.xy = rd.xy*mat2(cs, -si, si, cs); 
        
        // Passing a unit ray multiple into the Voronoi layer function, which 
        // is nothing more than an fBm setup with some time dialation.
        float c = noiseLayers(rd*2.);
        
        // Optional: Adding a bit of random noise for a subtle dust effect. 
        c = max(c + dot(hash33(rd)*2.-1., vec3(0.015)), 0.);

        // Coloring:
        
        // Nebula.
        c *= sqrt(c)*1.5; // Contrast.
        vec3 col = firePalette(c); // Palettization.
        col = mix(col, col.zyx*0.1+c*0.9, (1.+rd.x+rd.y)*0.45 ); // Color dispersion.
        
        // The fire palette on its own. Perhaps a little too much fire color.
        // c = pow(c, 1.33)*1.33;
        // vec3 col =  firePalette(c);
       
        // Black and white example
        // c *= sqrt(c)*1.5;
        // vec3 col = vec3(c);
        
        // Done.
        gl_FragColor = vec4(clamp(col, 0., 1.), 1.);

        // gl_FragColor = vec4(gl_FragCoord.x/1000.0,0.0,0.0,1.0);
    }
    </script>
    <script>
        var width = window.innerWidth;
        var height = window.innerHeight;
        // shader
        var uniforms = {};
        uniforms.resolution = { type: 'v2', value: { x: width, y: height, z:width}};
        uniforms.globalTime = { type: '1f', value: 0.0};



        
        var shader;
        var deltaTime = 0
        var lastFreq;
        
        function lerp(start, end, amt){
            return (1-amt)*start+amt*end
        }
        SPF.set({

            at: 'back',

            debug:true,

            load: function(PIXI, input){
                return [];
            },

            init: function(PIXI, input) {
                //add stuff to input.container to have it drawn
                var shaderCode = document.getElementById( 'fragShader' ).innerHTML
                shader = new PIXI.AbstractFilter('',shaderCode, uniforms);

                var bg = new PIXI.Sprite()
                bg.width = width;
                bg.height = height;
                bg.filters = [shader]
                input.container.addChild(bg);
            },

            render: function(PIXI, input) {
                deltaTime+=0.01
                if(input.audio != null && input.audio.frequencies != null){

                    var freqs = input.audio.frequencies()
                    if(lastFreq != null){
                        //modify globalTime according to frequency
                        var theta = freqs[0]/255-0.5
                        theta*=0.3
                        deltaTime+=theta

                    }
                    lastFreq = freqs
                }
                shader.uniforms.globalTime.value = deltaTime;
                
            },


            resize: function(PIXI, input, w, h) {

                // w += w*0.5;
                // h += h*0.5;

                // sprite.scale = new PIXI.Point(1,1);

                // ratio = w/h;

                // var width = w;
                // var height = h*ratio;

                // if(w <h){
                //     ratio = h/w;
                //     height = h;
                //     width = w*ratio;
                // };

                // sprite.width = width;
                // sprite.height = height;

                // sprite.position.x = w/3;
                // sprite.position.y = h/3;

            }

        });


        SPF.start();

    </script>


    </body>

</html>