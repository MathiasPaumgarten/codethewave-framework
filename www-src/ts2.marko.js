function create(__helpers) {
  var str = __helpers.s,
      empty = __helpers.e,
      notEmpty = __helpers.ne;

  return function render(data, out) {
    out.w('<!doctype html> <html class="no-js" lang><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><title>sp-framework</title><meta name="description" content><meta name="viewport" content="user-scalable=no, width=device-width"><link rel="apple-touch-icon" href="apple-touch-icon.png"><link rel="stylesheet" href="main.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/detectizr/2.2.0/detectizr.min.js"></script><script src="http://work.molamil.com/trouble/spxboplay/sp-framework/js/pixi.js"></script><script src="./js/popcorn.js"></script></head><body><!--[if lt IE 8]>\n\n        <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>\n\n    <![endif]--><script src="sp-framework.js"></script><script id="fragShader" type="shader-code">\n    precision mediump float;\n    uniform vec2      resolution;\n    uniform float     globalTime;\n    \n    \n    \n    vec3 firePalette(float i){\n\n        float T = 1400. + 1300.*i; // Temperature range (in Kelvin).\n        vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n        L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n        return 1.0-exp(-5e8/L); // Exposure level. Set to "50." For "70," change the "5" to a "7," etc.\n    }\n    // Hash function. This particular one probably doesn\'t disperse things quite as nicely as some \n    // of the others around, but it\'s compact, and seems to work.\n    //\n    vec3 hash33(vec3 p){ \n        \n        float n = sin(dot(p, vec3(7, 157, 113)));    \n        return fract(vec3(2097152, 262144, 32768)*n); \n    }\n    // 3D Voronoi: Obviously, this is just a rehash of IQ\'s original.\n    //\n    float voronoi(vec3 p){\n\n        vec3 b, r, g = floor(p);\n        p = fract(p); // "p -= g;" works on some GPUs, but not all, for some annoying reason.\n        \n        // Maximum value: I think outliers could get as high as "3," the squared diagonal length \n        // of the unit cube, with the mid point being "0.75." Is that right? Either way, for this \n        // example, the maximum is set to one, which would cover a good part of the range, whilst \n        // dispensing with the need to clamp the final result.\n        float d = 1.; \n         \n        \n        for(int j = -1; j <= 1; j++) {\n            for(int i = -1; i <= 1; i++) {\n                \n                b = vec3(i, j, -1);\n                r = b - p + hash33(g+b);\n                d = min(d, dot(r,r));\n                \n                b.z = 0.0;\n                r = b - p + hash33(g+b);\n                d = min(d, dot(r,r));\n                \n                b.z = 1.;\n                r = b - p + hash33(g+b);\n                d = min(d, dot(r,r));\n                    \n            }\n        }\n        \n        return d; // Range: [0, 1]\n    }\n    // Standard fBm function with some time dialation to give a parallax \n    // kind of effect. In other words, the position and time frequencies \n    // are changed at different rates from layer to layer.\n    //\n    float noiseLayers(vec3 p) {\n\n        // Normally, you\'d just add a time vector to "p," and be done with \n        // it. However, in this instance, time is added seperately so that \n        // its frequency can be changed at a different rate. "p.z" is thrown \n        // in there just to distort things a little more.\n        vec3 t = vec3(0., 0., p.z+globalTime*1.5);\n\n        const int iter = 5; // Just five layers is enough.\n        float tot = 0., sum = 0., amp = 1.; // Total, sum, amplitude.\n\n        for (int i = 0; i < iter; i++) {\n            tot += voronoi(p + t) * amp; // Add the layer to the total.\n            p *= 2.0; // Position multiplied by two.\n            t *= 1.5; // Time multiplied by less than two.\n            sum += amp; // Sum of amplitudes.\n            amp *= 0.5; // Decrease successive layer amplitude, as normal.\n        }\n        \n        return tot/sum; // Range: [0, 1].\n    }\n    void main(){\n        \n        // Screen coordinates.\n        vec2 uv = (gl_FragCoord.xy - resolution.xy*0.5) / resolution.y;\n        \n        // Shifting the central position around, just a little, to simulate a \n        // moving camera, albeit a pretty lame one.\n        uv += vec2(sin(globalTime*0.5)*0.25, cos(globalTime*0.5)*0.125);\n        \n        // Constructing the unit ray. \n        vec3 rd = normalize(vec3(uv.x, uv.y, 3.1415926535898/8.));\n\n        // Rotating the ray about the XY plane, to simulate a rolling camera.\n        float cs = cos(globalTime*0.25), si = sin(globalTime*0.25);\n        // Apparently "r *= rM" can break in some older browsers.\n        rd.xy = rd.xy*mat2(cs, -si, si, cs); \n        \n        // Passing a unit ray multiple into the Voronoi layer function, which \n        // is nothing more than an fBm setup with some time dialation.\n        float c = noiseLayers(rd*2.);\n        \n        // Optional: Adding a bit of random noise for a subtle dust effect. \n        c = max(c + dot(hash33(rd)*2.-1., vec3(0.015)), 0.);\n\n        // Coloring:\n        \n        // Nebula.\n        c *= sqrt(c)*1.5; // Contrast.\n        vec3 col = firePalette(c); // Palettization.\n        col = mix(col, col.zyx*0.1+c*0.9, (1.+rd.x+rd.y)*0.45 ); // Color dispersion.\n        \n        // The fire palette on its own. Perhaps a little too much fire color.\n        // c = pow(c, 1.33)*1.33;\n        // vec3 col =  firePalette(c);\n       \n        // Black and white example\n        // c *= sqrt(c)*1.5;\n        // vec3 col = vec3(c);\n        \n        // Done.\n        gl_FragColor = vec4(clamp(col, 0., 1.), 1.);\n\n        // gl_FragColor = vec4(gl_FragCoord.x/1000.0,0.0,0.0,1.0);\n    }\n    </script><script>\n        var width = window.innerWidth;\n        var height = window.innerHeight;\n        // shader\n        var uniforms = {};\n        uniforms.resolution = { type: \'v2\', value: { x: width, y: height, z:width}};\n        uniforms.globalTime = { type: \'1f\', value: 0.0};\n\n\n\n        \n        var shader;\n        var deltaTime = 0\n        var lastFreq;\n        \n        function lerp(start, end, amt){\n            return (1-amt)*start+amt*end\n        }\n        SPF.set({\n\n            at: \'back\',\n\n            debug:true,\n\n            load: function(PIXI, input){\n                return [];\n            },\n\n            init: function(PIXI, input) {\n                //add stuff to input.container to have it drawn\n                var shaderCode = document.getElementById( \'fragShader\' ).innerHTML\n                shader = new PIXI.AbstractFilter(\'\',shaderCode, uniforms);\n\n                var bg = new PIXI.Sprite()\n                bg.width = width;\n                bg.height = height;\n                bg.filters = [shader]\n                input.container.addChild(bg);\n            },\n\n            render: function(PIXI, input) {\n                deltaTime+=0.01\n                if(input.audio != null && input.audio.frequencies != null){\n\n                    var freqs = input.audio.frequencies()\n                    if(lastFreq != null){\n                        //modify globalTime according to frequency\n                        var theta = freqs[0]/255-0.5\n                        theta*=0.3\n                        deltaTime+=theta\n\n                    }\n                    lastFreq = freqs\n                }\n                shader.uniforms.globalTime.value = deltaTime;\n                \n            },\n\n\n            resize: function(PIXI, input, w, h) {\n\n                // w += w*0.5;\n                // h += h*0.5;\n\n                // sprite.scale = new PIXI.Point(1,1);\n\n                // ratio = w/h;\n\n                // var width = w;\n                // var height = h*ratio;\n\n                // if(w <h){\n                //     ratio = h/w;\n                //     height = h;\n                //     width = w*ratio;\n                // };\n\n                // sprite.width = width;\n                // sprite.height = height;\n\n                // sprite.position.x = w/3;\n                // sprite.position.y = h/3;\n\n            }\n\n        });\n\n\n        SPF.start();\n\n    </script></body></html>');
  };
}
(module.exports = require("marko").c(__filename)).c(create);