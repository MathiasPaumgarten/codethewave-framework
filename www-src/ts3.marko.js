function create(__helpers) {
  var str = __helpers.s,
      empty = __helpers.e,
      notEmpty = __helpers.ne;

  return function render(data, out) {
    out.w('<!doctype html> <html class="no-js" lang><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><title>sp-framework</title><meta name="description" content><meta name="viewport" content="user-scalable=no, width=device-width"><link rel="apple-touch-icon" href="apple-touch-icon.png"><link rel="stylesheet" href="main.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/detectizr/2.2.0/detectizr.min.js"></script><script src="http://work.molamil.com/trouble/spxboplay/sp-framework/js/pixi.js"></script><script src="./js/popcorn.js"></script></head><body><!--[if lt IE 8]>\n\n        <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>\n\n    <![endif]--><script src="sp-framework.js"></script><script id="fragShader" type="shader-code">\n    // inspired by "The Inversion Machine" by Kali on shadertoy beta\n    precision mediump float;\n    uniform vec2      resolution;\n    uniform float     deltaTime;\n    \n    const mediump float width=.22;\n    const mediump float scale=4.;\n    const mediump float detail=.002;\n    vec3 lightdir=-vec3(.2,.5,1.);\n\n    mat2 rot;\n\n    float rand(vec2 co){\n        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    }\n\n    float de(vec3 p) {\n        float t=deltaTime;\n        float dotp=dot(p,p);\n        p.x+=sin(t*40.)*.007;\n        p=p/dotp*scale;\n        p=sin(p+vec3(sin(1.+t)*2.,-t,-t*2.));\n        float d=length(p.yz)-width;\n        d=min(d,length(p.xz)-width);\n        d=min(d,length(p.xy)-width);\n        d=min(d,length(p*p*p)-width*.3);\n        return d*dotp/scale;\n    }\n\n    vec3 normal(vec3 p) {\n        vec3 e = vec3(0.0,detail,0.0);\n        \n        return normalize(vec3(\n                de(p+e.yxx)-de(p-e.yxx),\n                de(p+e.xyx)-de(p-e.xyx),\n                de(p+e.xxy)-de(p-e.xxy)\n                )\n            );  \n    }\n\n    float light(in vec3 p, in vec3 dir) {\n        vec3 ldir=normalize(lightdir);\n        vec3 n=normal(p);\n        float sh=1.;\n        float diff=max(0.,dot(ldir,-n))+.1*max(0.,dot(normalize(dir),-n));\n        vec3 r = reflect(ldir,n);\n        float spec=max(0.,dot(dir,-r))*sh;\n        return diff+pow(spec,20.)*.7;   \n    }\n\n    float raymarch(in vec3 from, in vec3 dir, in vec2 fragCoord){\n        vec2 uv = fragCoord.xy / resolution.xy*2.-1.;\n        uv.y*=resolution.y/resolution.x;\n        float st,d,col,totdist=st=0.;\n        vec3 p;\n        float ra=rand(uv.xy*deltaTime)-.5;\n        float ras=max(0.,sign(-.5+rand(vec2(1.3456,.3573)*floor(30.+deltaTime*20.))));\n        float rab=rand(vec2(1.2439,2.3453)*floor(10.+deltaTime*40.))*ras;\n        float rac=rand(vec2(1.1347,1.0331)*floor(40.+deltaTime));\n        float ral=rand(1.+floor(uv.yy*300.)*deltaTime)-.5;\n        for (int i=0; i<60; i++) {\n            p=from+totdist*dir;\n            d=de(p);\n            if (d<detail || totdist>2.) break;\n            totdist+=d; \n            st+=max(0.,.04-d);\n        }\n        vec2 li=uv*rot;\n        float backg=.45*pow(1.5-min(1.,length(li+vec2(0.,-.6))),1.5);\n        if (d<detail) {\n            col=light(p-detail*dir, dir); \n        } else { \n            col=backg;\n        }\n        col+=smoothstep(0.,1.,st)*.8*(.1+rab);\n        col+=pow(max(0.,1.-length(p)),8.)*(.5+10.*rab);\n        col+=pow(max(0.,1.-length(p)),30.)*50.;\n        col = mix(col, backg, 1.0-exp(-.25*pow(totdist,3.)));\n        if (rac>.7) col=col*.7+(.3+ra+ral*.5)*mod(uv.y+deltaTime*2.,.25);\n        col = mix(col, .5+ra+ral*.5, max(0.,3.-deltaTime)/3.);\n        return col+ra*.03+(ral*.1+ra*.1)*rab;\n    }\n    \n    void main(){\n        float t=deltaTime*.2;\n        vec2 uv = gl_FragCoord.xy / resolution.xy*2.-1.;\n        uv.y*=resolution.y/resolution.x;\n        vec3 from=vec3(0.,0.1,-1.2);\n        vec3 dir=normalize(vec3(uv,1.));\n        rot=mat2(cos(t),sin(t),-sin(t),cos(t));\n        dir.xy=dir.xy*rot;\n        float col=raymarch(from,dir,gl_FragCoord.xy);\n        col=pow(col,1.25)*clamp(60.-deltaTime,0.,1.);\n        gl_FragColor = vec4(col);\n        // Done.\n        // gl_FragColor = vec4(clamp(col, 0., 1.), 1.);\n\n        // gl_FragColor = vec4(gl_FragCoord.x/1000.0,0.0,0.0,1.0);\n    }\n    </script><script>\n        var width = window.innerWidth;\n        var height = window.innerHeight;\n        // shader\n        var uniforms = {};\n        uniforms.resolution = { type: \'v2\', value: { x: width, y: height, z:width}};\n        uniforms.deltaTime = { type: \'1f\', value: 5.0};\n\n\n\n        \n        var shader;\n        var deltaTime = 0\n        var lastFreq;\n        var speed = 0.03;\n        \n        function lerp(start, end, amt){\n            return (1-amt)*start+amt*end\n        }\n        \n        SPF.set({\n\n            at: \'back\',\n\n            debug:true,\n\n            load: function(PIXI, input){\n                return [];\n            },\n\n            init: function(PIXI, input) {\n                //add stuff to input.container to have it drawn\n                var shaderCode = document.getElementById( \'fragShader\' ).innerHTML\n                shader = new PIXI.AbstractFilter(\'\',shaderCode, uniforms);\n\n                var bg = new PIXI.Sprite()\n                bg.width = width;\n                bg.height = height;\n                bg.filters = [shader]\n                input.container.addChild(bg);\n            },\n\n            render: function(PIXI, input) {\n                deltaTime+=speed\n                if(deltaTime<4 && speed<0){\n                    speed*=-1\n                }else if(deltaTime>54 && speed >0){\n                    speed*=-1\n                }\n                if(input.audio != null && input.audio.frequencies != null){\n\n                    var freqs = input.audio.frequencies()\n                    if(lastFreq != null){\n                        //modify deltaTime according to frequency\n                       \n                        var theta = freqs[0]/255-0.6\n                        theta*=0.06\n                        deltaTime+=theta\n                        \n\n\n                    }\n                    lastFreq = freqs\n                }\n                SPF.log("deltaTime", deltaTime)\n                shader.uniforms.deltaTime.value = deltaTime;\n                \n            },\n\n\n            resize: function(PIXI, input, w, h) {\n\n                // w += w*0.5;\n                // h += h*0.5;\n\n                // sprite.scale = new PIXI.Point(1,1);\n\n                // ratio = w/h;\n\n                // var width = w;\n                // var height = h*ratio;\n\n                // if(w <h){\n                //     ratio = h/w;\n                //     height = h;\n                //     width = w*ratio;\n                // };\n\n                // sprite.width = width;\n                // sprite.height = height;\n\n                // sprite.position.x = w/3;\n                // sprite.position.y = h/3;\n\n            }\n\n        });\n\n\n        SPF.start();\n\n    </script></body></html>');
  };
}
(module.exports = require("marko").c(__filename)).c(create);